%% Introduction to GAIL Option Pricing
% In |BrownianMotionExample| we saw an example of the |brownianMotion|
% class, and in |OptionPricingMeanMC_g| we saw a brief introduction to the
% GAIL classes for option pricing.  This is a more thorough introduction.
%
% GAIL (the develop branch) has a hierachy of classes
%
% * |stochProcess| is a |handle| subclass
% * |whiteNoise| is a subclass of |stochProcess| for generating IID random
% vectors
% * |brownianMotion| is a subclass of |whiteNoise| for generating samples of
% Brownian Motions
% * |assetPath| is a subclass of |brownianMotion| for generating samples of
% asset or stock price paths
% * |optPayoff| is a subclass of |assetPath| for generating samples of
% payoffs of various kinds of options
% * |optPrice| is a subclass of |optPayoff| for approximating option prices
% using Monte Carlo methods

%% |assetPath| objects
% In |BrownianMotionExample| we generated a |brownianMotion| object by
% specifying the time vector.  Here we repeat that, but with a coarser time
% discretization

gail.InitializeWorkspaceDisplay %initialize the workspace and the display parameters
inp.timeDim.timeVector = 0.25:0.25:1; %time increments of 0.004 up to time 1
ourBrownianMotion = brownianMotion(inp) %construct a brownianMotion object

%%
% To generate an asset path modeled by a geometric Brownian motion we need
% to add some more properties

inp.assetParam.initPrice = 120; %initial stock price
inp.assetParam.interest = 0.01; %risk-free interest rate
inp.assetParam.volatility = 0.5; %volatility
ourAssetPath = assetPath(inp) %construct an assetPath object

%% 
% We generate some paths with the |genPaths| method:

methods(ourAssetPath)
n = 10; %number of paths to generate
aPaths = genPaths(ourAssetPath,n) %an n by 250 matrix of numbers

%%
% Next we use the |plot| method to plot some asset paths

n = 20; %number of paths to plot
plot(ourAssetPath,n) %plot n paths
xlabel('Time')
ylabel('Asset Paths')
print -depsc AssetPaths.eps

%% |optPayoff| objects
%%
% To generate some discounted option payoffs to add some more properties

inp.payoffParam.strike = 130; %initial stock price
ourCallPayoff = optPayoff(inp) %construct an optPayoff object

%% 
% Note that the default is a European call option.  We generate some paths
% with the |genOptPayoffs| method:

methods(ourCallPayoff)
n = 10; %number of paths to generate
Payoffs = genOptPayoffs(ourCallPayoff,n) %an n vector of numbers

%%
% Next we use the |plot| method to plot the empirical distribution function
% of some option payoffs

n = 1e3; %number of paths to plot
plot(ourCallPayoff,n) %plot n paths
xlabel('Discounted Payoff')
ylabel('Probability')
print -depsc EuropeanCallOptionPayoffs.eps

%% |optPrice| objects
% Finally, to automate the pricing of options, we can create |optPrice|
% objects that use |meanMC_g| to compute the option price by Monte Carlo.

inp.priceParam.absTol = 0; %absolute tolerance
inp.priceParam.relTol = 0.005; %one penny on the dollar relative tolerance
ourCallPrice = optPrice(inp) %construct an optPrice object 

%% 
% Note that for this option, the true price is known.
% 
% To compute the option price by Monte Carlo we execute the command

[CallPrice, out] = genOptPrice(ourCallPrice) %the option price

%% 
% Note that the price generated by Monte Carlo is within the tolerance of
% the exact price.
%
% As noted elsewhere, we do not really need to know the stock price at so
% many time steps to price a European option.  Thus, we can change the time
% vector and price it again.

ourCallPrice.timeDim.timeVector = 1
[CallPrice,out] = genOptPrice(ourCallPrice) %the option price

%% 
% The time is now about a quarter of what it was before.
%
% We can also change to a put option.  First we make a new copy of our
% |optPrice| object, and then we change the property
% |payoffParam.putCallType|.

ourPutPrice = optPrice(ourCallPrice); %make a new object with same properties as the call
ourPutPrice.payoffParam.putCallType = {'put'}
[PutPrice,out] = genOptPrice(ourPutPrice) %the option price


%%
% The time to price the put option is less than the time to price the call
% option.  Do you know why?
%
% We know that the time recorded tracks the number of samples needed, which
% in turn is related to the error tolerance as follows:
%
% \[\text{number of samples needed} = n = \mathcal{O}\biggl(
% \frac{\text{var}(\text{payoff})}{\text{tolerance}^2} \biggr). 
% \]
% 
% For the the call and put options this factor on the right is as follows:

callRHS = var(genOptPayoffs(ourCallPrice,1e4)) ...
   /(ourCallPrice.priceParam.relTol*CallPrice)^2
putRHS = var(genOptPayoffs(ourPutPrice,1e4)) ...
   /(ourPutPrice.priceParam.relTol*PutPrice)^2

%%
% We can see that the right hand side for the call is much more than for
% the put, although not by the factor that we might expect.  This may be
% due to some of the overhead involved |meanMC_g| using a relative error
% criterion.  If we use a pure absolute error criterion then the relative
% times are closer to the ratio of the right hand sides of the formula for
% \(n\) above.

ourCallPrice.priceParam.relTol=0;
ourCallPrice.priceParam.absTol=0.1
[CallPrice,out] = genOptPrice(ourCallPrice) %the option price

ourPutPrice.priceParam.relTol=0;
ourPutPrice.priceParam.absTol=0.1
[PutPrice,out] = genOptPrice(ourPutPrice) %the option price

callRHS = var(genOptPayoffs(ourCallPrice,1e4)) ...
   /(ourCallPrice.priceParam.absTol)^2
putRHS = var(genOptPayoffs(ourPutPrice,1e4)) ...
   /(ourPutPrice.priceParam.absTol)^2

%%
% _Author: Fred J. Hickernell_

